#include "eiqueue.h"
#include <stdlib.h>
#include "eiLib/eiCom.h"

eiQueue::eiQueue()
{
   front = -1;
   rear = -1;
}

void eiQueue::Enqueue(const char * id, const char * msg, int len)
{
   // Don't allow the queue to grow more
   // than MAX_SIZE - 1
   if ( Size() == MAX_SIZE - 1 )
       //throw new QueueOverFlowException();
{
       return;
   }
   data[rear].msglen = elemeen;
   memcpy(data[rear].msgbuffer, element.msgbuffer, element.msglen);
   memcpy(data[rear].msgid, element.msgid, MSGIDLEN +1);

   // MOD is used so that rear indicator
   // can wrap around
   rear = ++rear % MAX_SIZE;
}

void eiQueue::Enqueue(const msgRecord & element)
{
   // Don't allow the queue to grow more
   // than MAX_SIZE - 1
   if ( Size() == MAX_SIZE - 1 )
       //throw new QueueOverFlowException();
{
       return;
   }
   data[rear].msglen = element.msglen;
   memcpy(data[rear].msgbuffer, element.msgbuffer, element.msglen);
   memcpy(data[rear].msgid, element.msgid, MSGIDLEN +1);

   // MOD is used so that rear indicator
   // can wrap around
   rear = ++rear % MAX_SIZE;
}
msgRecord empty;
const msgRecord & eiQueue::Dequeue()
{
   if ( isEmpty() )
    {
       return  empty;
   }
    //   throw new QueueEmptyException();

   //int ret = data[front];
   int idx = front;

   // MOD is used so that front indicatord
   // can wrap around
   front = ++front % MAX_SIZE;

   return data[idx];
}

const msgRecord & eiQueue::Front()
{
   if ( isEmpty() )
      // throw new QueueEmptyException();
{
       return empty;
   }
   return data[front];
}

int eiQueue::Size()
{
   return abs(rear - front);
}

bool eiQueue::isEmpty()
{
   return ( front == rear ) ? true : false;
}



