#ifndef EICOM_H_
#define EICOM_H_

#include "comIO.h"
#include <memory.h>
#include <stdio.h>

typedef enum _msgID
{
	Subscribe,
    Notify,
    Cmd
}MSGID;

const int EI_USER = 1000;

typedef enum msg_cmd
{
    UpdateIOPoint = EI_USER,
    UpdateDisplayWidget,
    UpdateDisplay,
    UpdateModule,
    UpdateConnection,

}MSG_CMD;

typedef enum cmd_action
{
    ca_ADD,
    ca_CHANGE,
    ca_DELETE,
    ca_OBSERVE
}CMD_ACTION;


typedef enum _state
{
	CREATED,
	RUNNING,
	PAUSED,

}STATE;


typedef enum _cmd
{
	RUN,
	PAUSE,
	RESTART,

}CMD;







const int MSGBODYTOLONG = -1;

   // STX, HDRLEN, MSGID, MSGLEN,SECID, MSGBODY,  ETX


// msg and header item sizes
static const int MAXMSGLEN = 512;
static const int MSGIDLEN = 4;
static const int MSGLENLEN = 4;
static const int MSGSECIDLEN = 4;
static const int MSGCODELEN = 1;
static const int MSGHDRLENLEN = 1;
static const int MSGSEQIDLEN = 1;

enum hdroffsets
{
    MSGSTXOFFSET    = 0,
    MSGCODEOFFSET   = MSGSTXOFFSET + 1,
    MSGHDRLENOFFSET = MSGCODEOFFSET + MSGCODELEN,
    MSGIDOFFSET     = MSGHDRLENOFFSET + MSGHDRLENLEN,
    MSGSEQIDOFFSET  = MSGIDOFFSET + MSGIDLEN,
    MSGLENOFFSET    = MSGSEQIDOFFSET       + MSGSEQIDLEN,
    MSGSECIDOFFSET  = MSGLENOFFSET      + MSGLENLEN,
    MSGBODYOFFSET   = MSGSECIDOFFSET    + MSGSECIDLEN
};

class msgRecord
{
    char msgid[MSGIDLEN+1];
    int msglen;
    char msgbuffer[MAXMSGLEN];
public:
    void update(const char * id, const int len, const char * buffer)
    {
        memcpy(msgbuffer, buffer, len);
        msgbuffer[len]=0;
        memcpy(msgid, id, MSGIDLEN);
        msgid[MSGIDLEN] = 0;
        msglen = len;
    }

    const char * getBuffer()
    {
        return msgbuffer;
    }
};



//msg values
static char STX = 0x02;
static char ETX = 0x03;
static char eiMsgID[] = "ei";
static const int MAXBODYLEN = MAXMSGLEN - MSGBODYOFFSET;
static const char MSGHDRLEN = MSGBODYOFFSET;

typedef struct msgHeader
{
    int hdrlen;
    char eiMsgCode[MSGCODELEN+1];
    char msgID[MSGIDLEN+1];
    long msgLen;
    char secid[MSGSECIDLEN + 1];
}MSGHEADER;
typedef union _val {
    char buff[8];
    long lval;
}VAL;

class eiMsg
{
    char _msgBuffer[MAXMSGLEN +1];
    long _len;
    char _id[MSGIDLEN+1];
public:
    eiMsg();

    char * body();
    char *  msgID();
    long len(void);

    const char * msg(){return _msgBuffer;}

    long setBody(const char * msgId, const void * body, long len);
    void setLen(const long msgLen);
    void setID(const char * id);
    void dump();

};

const int MSGRECORDSTACKSIZE = 10;




class MsgRecordMgr
{

    typedef struct msgRecordStackEntry
    {
        msgRecord * rec;
        msgRecord * next;
    };
    msgRecord msgRecords[MSGRECORDSTACKSIZE];
    int low=0;
    int high = 0;
    int lastAdded=0;
    msgRecordStackEntry stack[MSGRECORDSTACKSIZE]
  public:
    int addMessage(const char * id, const char * msg, const int len)
    {
        int idx;
        if(lastAdded < MSGRECORDSIZE)
        {
            lastAdded++;
            high = lastAdded;
       }
        else
        {
            lastAdded = 0;

        }
        idx = lastAdded;

        msgRecords[idx].update(id, len, msg);
        printf("msg added %d\n", idx);
        return 0;

    }
    msgRecord * nextMessage()
    {

    }

